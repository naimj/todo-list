const filterTrads = (items, q, codeLower) => {
  return items.filter(({ TRADUCTION }) => {
    const t = TRADUCTION?.toLowerCase() || ''
    return t.includes(q) || codeLower.includes(q)
  })
}

const searchResult = (query) => {
  const q = query.trim().toLowerCase()
  if (!q) return groupedData.value

  const result = {}

  for (const [domaine, codes] of Object.entries(groupedData.value)) {
    for (const [codeTrad, items] of Object.entries(codes)) {
      const filteredItems = filterTrads(items, q, codeTrad.toLowerCase())
      if (filteredItems.length) {
        result[domaine] ??= {}
        result[domaine][codeTrad] = filteredItems
      }
    }
  }

  return result
}

const onSearchQuery = useDebounceFn(async () => {
  const q = searchTrad.value.trim()

  // 1. filtrage
  filteredData.value = searchResult(q)

  // 2. ouverture
  if (q) {
    await openAllWithLoader()   // <<--- ici on appelle ta fonction
  } else {
    openedDomains.value = []
    openedCodes.value = {}
  }
}, 250)

const openAllWithLoader = async () => {
  loader.show()
  await nextTick() // laisse le temps d'afficher le loader

  const domainKeys = Object.keys(filteredData.value)
  openedDomains.value = domainKeys
  openedCodes.value = {}

  let i = 0
  function step() {
    if (i >= domainKeys.length) {
      loader.hide()
      return
    }
    const domain = domainKeys[i]
    openedCodes.value[domain] = Object.keys(filteredData.value[domain])
    i++
    setTimeout(step, 30) // ouvre domaine par domaine
  }
  step()
}
