const filterTrads = (items, searchValue, codeTrad) => {
    return items.filter(({ TRADUCTION }) => {
        if (TRADUCTION?.toLowerCase().includes(searchValue) || codeTrad.toLowerCase().includes(searchValue)) {
            return true;
        }

        return false;
    });
};

const searchResult = async () => {
    const searchValue = searchTrad.value.trim().toLowerCase();
    const result = {};

    if (!searchValue) {
        filteredData.value = groupedData.value;

        return;
    }

    for (const [domaine, codes] of Object.entries(groupedData.value)) {
        for (const [codeTrad, items] of Object.entries(codes)) {
            const filteredItems = filterTrads(items, searchValue, codeTrad);

            if (filteredItems.length) {
                result[domaine] ??= {};
                result[domaine][codeTrad] = filteredItems;
            }
        }
    }

    filteredData.value = result;

    return filteredData.value;
};

const onSearchQuery = useDebounceFn(() => {
    filteredData.value = groupedData.value;

    searchResult();

    const domainKeys = Object.keys(filteredData.value);
    const codesToOpen = {};

    openedDomains.value = domainKeys;

    domainKeys.forEach((domain) => {
        codesToOpen[domain] = Object.keys(filteredData.value[domain]);
    });

    openedCodes.value = codesToOpen;

    if (!searchTrad.value.trim()) {
        openedDomains.value = [];
        openedCodes.value = {};
    }
}, 300);
